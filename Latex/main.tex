\documentclass{rapport}
\usepackage{lipsum}
\usepackage{gensymb}
\usepackage{float}
\usepackage{listings}
\usepackage{graphicx} % Required for inserting images
\title{file title} %title of the file

\begin{document}

%----------- Report information ---------

\logo{logos/uvsq.jpg}
\uni{\textbf{Théorie des langages}}
\ttitle{Projet Transformation de grammaires} %title of the file
\subject{in520} % Subject name
\topic{Assignment 2} % Topic name

\professor{Franck \textsc{Quessette}} 

\students{Daria KURGANSKAYA \\ 22201683 \\
          Maryatou KANTE\\22201575}

%----------- Init -------------------
        
\buildmargins % display margins
\buildcover % create the front cover of the document
\toc % creates the table of contents

\section{Notations}
\textit{NonTer} - non terminale \\
\textit{Ter} - terminale \\
\textit{Val} - terminale ou non terminale du membre gauche \\
\textit{MbrDroit} - membre droit \\
\textit{MbrGauche} - membre gauche \\

\section{Choix de la structure de données}
Afin de réaliser notre projet de transformation de grammaires en Python, nous avons opté pour la structure de donnés suivante : les dictionnaires dont les clés sont des membres droits des règles et les valeurs: la liste des membres gauches associées au membre droit donné. Chaque membre gauche est aussi une liste dont les valeurs sont des ternimaux ou non terminaux qui composent la règle. De cette manière des valeurs du dictionnaire sont des liste des listes.\\

\textit{grammaire = {MbrDroit (NonTer) : [[Val1 du MbrGauche1, Val2 du MbrGauche1], [Val1 du MbrGauche2]]}}\\

Afin d'eviter les confusions l'axiome est stokée dans une variable à part.\\
Cette structure de données confère plusieurs avantages qui facilitent grandement de traitement des règles de grammaires: \\

\begin{enumerate}
\item Accès rapide aux éléments \\
Il est très simple de rechercher une règle particulière. En effet, les clés représentant le membre gauche et les valeurs représentant les membres droits, il est très rapide de rechercher une règle spécifique dans l'ensemble de règles (beaucoup plus efficace qu'une liste).

\item Les règles sont facilement organisables. \\ Une clé représente un non-terminal (membre gauche), et la valeur associée est une liste de sous-listes, chaque sous-liste représentant un membre droit associé au non-terminal du membre gauche. Grâce au système clé/valeur, il est simple d’accéder à une règle particulière en recherchant la clé. De plus, la modification, la suppression ou l’ajout de membres gauches associés est très simple grâce au système de liste. Enfin, il est aisé d'ajouter de nouveaux couples clé/valeur si nécessaire (par exemple, lors de la conversion en forme normale de Chomsky ou de Greibach).\\

\item Lisibilité\\
Cette structure de données étant très simple, elle est très lisible et donc facilement compréhensible. Étant donné qu’une grammaire peut contenir de nombreuses règles, il est crucial de pouvoir les distinguer clairement afin d’éviter les erreurs. Les dictionnaires n’ont pas ce problème grâce à leur organisation claire et structurée. \\

\end{enumerate}

\section{Les algorithmes}

\subsection{Lecture/Ecriture}
Lecture \\
Le fichier lu en entrée et ayant une extention general/chomsky/greibach chaque ligne comprend une règle de la grammaire sous la forme :  membre_gauche:membre_droit. Ce fichier est lu ligne par ligne. Grâce aux fonctions split et strip les lignes sont ensuite  décomposées en membre droit et membre gauche et les espaces entre les symbole enlevée. Chaque membre droit est ensuite décomposé en liste de non terminaux et ternimaux avant d'être ajouté aux distionnaire des regles. L'axiome est le membre droit de la première ligne\\

Ecriture \\
Les règles normaux sont écrit en fonction 

\subsection{Algorithmes supplementaires}
Gestion/Creation des non terminaux \\
Afin de pouvoir crer de nouveax non terminaux 2 variables sont utilisées : la premiere stocke la lettre du non terminale courant de A à Z et la deuxième qui stocke le numéro du non terminale courant (de 0 à 9). \\

Après la lecture des fichier la lettre et le numéro courrants sont §§§ au non terminale le plus grand utilisé, c'est à dire, celui dont la lettre est la lettre dont la valeur du code ascii est la plus importante et le plus grand numéro des membres droits commençants par cette lettre.

Afin de creer un nouvel non ternimal le numéro du non terminale courrant est augmenter. S'il est impossible d'incrementer le numéro, le code ascii de la lettre courrante est incrémenté et le numéro redevient 0. Lorsqu'il est impossible de creer un nouvel non ternimale car le non ter,inal courrant est Z9, une fonction de suppréssion des non ternimaux non utilisée est utilisée et tous les non ternimaux sont renommés en commençant par A0.
S'il est impossible de liberer des non terminaux le programme renvoye une erreur §§§

Cette structure a ete choisie car est facilement §§§scalable§§§ en cas de changement de règles de nommage des non ternimaux. En cas d'augmentation des non terminaux possible (ex: 1 lettre et 5 nombres) cette méthode prends moins d'espaces mémoires que par exemple les tableaux de n valeurs qui indique si le terminale n est pris ou pas.
Cette méthode peut nécessiter une renommage des non ternimaux si le fichier des règles initiales contients des non terminaux qui §§§ mais cela reste un fait rare.

Collecte des non terminaux
L'algorithme de collecte des non terminaux supprime les règles non accessibles depuis l'axiome et les règles dont les membres gauches sont strictement identiques. Puis il effectue le renommage de tous les non terminaux à partir de A0.


Fonctions de changements de formes








%------------ Report body ----------------

 
\end{document}
